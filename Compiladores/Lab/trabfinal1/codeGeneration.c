#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "symbolTable.h"
#include "codeGeneration.h"

// Global variables
extern SymTable table;
extern FILE *out_file;
static int label_counter = 0;

void resetLabelCounter()
{
    label_counter = 0;
}

// Function to create assembly file preamble
void makePreambule(const char *filename)
{
    // Assembly format header with detailed comments
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "; Assembly code generated from: %s\n", filename);
    fprintf(out_file, "; Generated by UFMT Compiler Lab Project\n");
    fprintf(out_file, "; Author: Wesley Antonio Junior dos Santos\n");
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "\n");

    // External function declarations
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "; External function declarations\n");
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "extern printf                   ; C standard library printf\n");
    fprintf(out_file, "extern scanf                    ; C standard library scanf\n");
    fprintf(out_file, "extern exit                     ; C standard library exit\n");
    fprintf(out_file, "\n");

    // Data section with format strings and variables
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "; Data section - Constants and Variables\n");
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "section .data\n");
    fprintf(out_file, "    ; Format strings for I/O operations\n");
    fprintf(out_file, "    fmt_d:       db \"%%ld\", 0          ; Integer format (no newline)\n");
    fprintf(out_file, "    fmt_f:       db \"%%lf\", 0          ; Float format (no newline)\n");
    fprintf(out_file, "    fmt_s:       db \"%%s\", 0          ; String format (no newline)\n");
    fprintf(out_file, "    fmt_dln:     db \"%%ld\", 10, 0     ; Integer format (with newline)\n");
    fprintf(out_file, "    fmt_fln:     db \"%%lf\", 10, 0     ; Float format (with newline)\n");
    fprintf(out_file, "    fmt_sln:     db \"%%s\", 10, 0      ; String format (with newline)\n");
    fprintf(out_file, "\n");
    fprintf(out_file, "    ; Temporary variables\n");
    fprintf(out_file, "    temp_float:  dq 0.0              ; Temporary for float conversions\n");
    fprintf(out_file, "\n");
    fprintf(out_file, "    ; Program variables\n");
}

// End of data section and beginning of code section
void dumpCodeDeclarationEnd()
{
    // Add all declared variables to the data section
    for (int i = 0; i < table.max_size; i++)
    {
        if (table.array[i].data.identifier[0] != '\0')
        {
            SymTableNode *node = &table.array[i];
            while (node != NULL)
            {
                fprintf(out_file, "    %s:          dq 0", node->data.identifier);
                if (node->data.type == REAL)
                {
                    fprintf(out_file, ".0");
                }
                fprintf(out_file, "              ; %s variable\n",
                        node->data.type == INTEGER ? "Integer" : "Float");
                node = node->next;
            }
        }
    }

    fprintf(out_file, "\nsection .text\n");
    fprintf(out_file, "global main\n");
    fprintf(out_file, "\n");
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "; Main program entry point\n");
    fprintf(out_file, "; ===============================================\n");
    fprintf(out_file, "main:\n");
    fprintf(out_file, "    ; Initialize stack frame\n");
    fprintf(out_file, "    push rbp                    ; Save base pointer\n");
    fprintf(out_file, "    mov rbp, rsp                ; Set new base pointer\n");
    fprintf(out_file, "\n");
    fprintf(out_file, "    ; Program execution starts here\n");
}

// Function to create assembly file epilogue
void makeCodeEpilogue(void)
{
    // Add final cleanup code to the existing main function
    fprintf(out_file, "\n");
    fprintf(out_file, "    ; Program cleanup and exit\n");
    fprintf(out_file, "    mov rsp, rbp                ; Restore stack pointer\n");
    fprintf(out_file, "    pop rbp                     ; Restore base pointer\n");
    fprintf(out_file, "    mov rdi, 0                  ; Exit status\n");
    fprintf(out_file, "    call exit                   ; Exit program\n");
    fprintf(out_file, "\n");
}
void makeCodeDeclaration(char *dest, char *identifier, Type type, char *value)
{
    // Don't generate code here - variables will be declared in dumpCodeDeclarationEnd
    // Suppress unused parameter warnings
    (void)identifier;
    (void)type;
    (void)value;

    dest[0] = '\0'; // Empty string
}

int makeCodeAssignment(char *dest, char *id, char *expr)
{
    SymTableEntry *ret = findSymTable(&table, id);
    dest[0] = '\0';

    // Validation already done in the syntactic analyzer
    if (ret->type == INTEGER || ret->type == REAL)
    {
        sprintf(dest + strlen(dest), "%s", expr);
        sprintf(dest + strlen(dest), "    pop rbx\n");
        sprintf(dest + strlen(dest), "    mov [%s], rbx\n", ret->identifier);
    }
    else
    {
        fprintf(stderr, "Unsupported operation involving string at line %d\n",
                cont_lines);
        return 0;
    }
    return 1;
}

// Type checking utilities
Type getExpressionType(char *expr)
{
    (void)expr; // Suppress unused parameter warning
    // Esta função deve ser implementada no parser para retornar o tipo da expressão
    // Por simplicidade, vamos assumir que podemos determinar o tipo
    // Na implementação real, isso seria feito durante a análise sintática
    return INTEGER; // Placeholder - deve ser implementado adequadamente
}

int checkTypeCompatibility(Type type1, Type type2)
{
    return (type1 == type2);
}

// Function to print type mismatch error
void printTypeMismatchError(int line, const char *operation, Type type1, Type type2)
{
    const char *type1_str = (type1 == INTEGER) ? "int" : ((type1 == REAL) ? "float" : "string");
    const char *type2_str = (type2 == INTEGER) ? "int" : ((type2 == REAL) ? "float" : "string");

    fprintf(stderr, "Error at line %d: Type mismatch in %s operation. Cannot operate %s with %s.\n",
            line, operation, type1_str, type2_str);
}

int makeCodeLoad(char *dest, char *id, int ref)
{
    dest[0] = '\0';

    if (ref == 0)
    {
        // It's a numeric literal (integer or float)
        if (strchr(id, '.') != NULL)
        {
            // It's a float number
            double val = atof(id);
            long *bits = (long *)&val;
            sprintf(dest + strlen(dest), "    ; Load float literal: %s\n", id);
            sprintf(dest + strlen(dest), "    mov rbx, %ld                ; Load float bits\n", *bits);
        }
        else
        {
            // It's an integer number - load as integer
            int val = atoi(id);
            sprintf(dest + strlen(dest), "    ; Load integer literal: %s\n", id);
            sprintf(dest + strlen(dest), "    mov rbx, %d                ; Load integer value\n", val);
        }
        sprintf(dest + strlen(dest), "    push rbx\n");
        return 1;
    }

    SymTableEntry *ret = findSymTable(&table, id);
    // Validation already done in the syntactic analyzer

    sprintf(dest + strlen(dest), "    mov rbx, [%s]\n", ret->identifier);
    sprintf(dest + strlen(dest), "    push rbx\n");
    return 1;
}

void makeCodeAdd(char *dest, Type type)
{
    char temp[256];
    if (type == INTEGER)
    {
        sprintf(temp, "    ; Integer addition operation\n");
        strcat(dest, temp);
        strcat(dest, "    pop rcx                     ; Get second operand\n");
        strcat(dest, "    pop rbx                     ; Get first operand\n");
        strcat(dest, "    add rbx, rcx                ; Add: rbx = rbx + rcx\n");
        strcat(dest, "    push rbx                    ; Push result\n");
    }
    else if (type == REAL)
    {
        sprintf(temp, "    ; Float addition operation\n");
        strcat(dest, temp);
        strcat(dest, "    pop rcx                     ; Get second operand\n");
        strcat(dest, "    pop rbx                     ; Get first operand\n");
        strcat(dest, "    ; Convert to float for addition\n");
        strcat(dest, "    mov [temp_float], rbx       ; Store first operand\n");
        strcat(dest, "    movsd xmm0, [temp_float]    ; Load as double\n");
        strcat(dest, "    mov [temp_float], rcx       ; Store second operand\n");
        strcat(dest, "    movsd xmm1, [temp_float]    ; Load as double\n");
        strcat(dest, "    addsd xmm0, xmm1            ; Add: xmm0 = xmm0 + xmm1\n");
        strcat(dest, "    movsd [temp_float], xmm0    ; Store result\n");
        strcat(dest, "    mov rbx, [temp_float]       ; Load result back\n");
        strcat(dest, "    push rbx                    ; Push result\n");
    }
}

void makeCodeSub(char *dest, Type type)
{
    if (type == INTEGER)
    {
        sprintf(dest + strlen(dest), "    ; Integer subtraction operation\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    sub rbx, rcx                ; Subtract: rbx = rbx - rcx\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push result\n");
    }
    else if (type == REAL)
    {
        sprintf(dest + strlen(dest), "    ; Float subtraction operation\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    ; Convert to float for subtraction\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rbx       ; Store first operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm0, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rcx       ; Store second operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm1, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    subsd xmm0, xmm1            ; Subtract: xmm0 = xmm0 - xmm1\n");
        sprintf(dest + strlen(dest), "    movsd [temp_float], xmm0    ; Store result\n");
        sprintf(dest + strlen(dest), "    mov rbx, [temp_float]       ; Load result back\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push result\n");
    }
}

void makeCodeMul(char *dest, Type type)
{
    if (type == INTEGER)
    {
        sprintf(dest + strlen(dest), "    ; Integer multiplication operation\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rax                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    imul rax, rcx               ; Multiply: rax = rax * rcx\n");
        sprintf(dest + strlen(dest), "    mov rbx, rax                ; Move result to rbx\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push result\n");
    }
    else if (type == REAL)
    {
        sprintf(dest + strlen(dest), "    ; Float multiplication operation\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    ; Convert to float for multiplication\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rbx       ; Store first operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm0, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rcx       ; Store second operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm1, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    mulsd xmm0, xmm1            ; Multiply: xmm0 = xmm0 * xmm1\n");
        sprintf(dest + strlen(dest), "    movsd [temp_float], xmm0    ; Store result\n");
        sprintf(dest + strlen(dest), "    mov rbx, [temp_float]       ; Load result back\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push result\n");
    }
}

void makeCodeDiv(char *dest, Type type)
{
    if (type == INTEGER)
    {
        sprintf(dest + strlen(dest), "    ; Integer division operation with zero check\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand (divisor)\n");
        sprintf(dest + strlen(dest), "    pop rax                     ; Get first operand (dividend)\n");
        sprintf(dest + strlen(dest), "    ; Check for division by zero\n");
        sprintf(dest + strlen(dest), "    cmp rcx, 0                  ; Compare divisor with zero\n");
        sprintf(dest + strlen(dest), "    je division_by_zero         ; Jump if divisor is zero\n");
        sprintf(dest + strlen(dest), "    ; Perform integer division\n");
        sprintf(dest + strlen(dest), "    xor rdx, rdx                ; Clear remainder register\n");
        sprintf(dest + strlen(dest), "    idiv rcx                    ; Divide: rax = rax / rcx\n");
        sprintf(dest + strlen(dest), "    mov rbx, rax                ; Move quotient to rbx\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push quotient\n");
        sprintf(dest + strlen(dest), "    jmp division_end            ; Skip error handling\n");
        sprintf(dest + strlen(dest), "\ndivision_by_zero:\n");
        sprintf(dest + strlen(dest), "    mov rdi, 1                  ; Exit code 1\n");
        sprintf(dest + strlen(dest), "    call exit                   ; Exit with error\n");
        sprintf(dest + strlen(dest), "\ndivision_end:\n");
    }
    else if (type == REAL)
    {
        sprintf(dest + strlen(dest), "    ; Float division operation with zero check\n");
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand (divisor)\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand (dividend)\n");
        sprintf(dest + strlen(dest), "    ; Check for division by zero\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rcx       ; Store divisor\n");
        sprintf(dest + strlen(dest), "    movsd xmm1, [temp_float]    ; Load divisor as double\n");
        sprintf(dest + strlen(dest), "    xorpd xmm2, xmm2            ; Clear xmm2 (zero)\n");
        sprintf(dest + strlen(dest), "    comisd xmm1, xmm2           ; Compare with zero\n");
        sprintf(dest + strlen(dest), "    je division_by_zero         ; Jump if divisor is zero\n");
        sprintf(dest + strlen(dest), "    ; Convert to float for division\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rbx       ; Store dividend\n");
        sprintf(dest + strlen(dest), "    movsd xmm0, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    divsd xmm0, xmm1            ; Divide: xmm0 = xmm0 / xmm1\n");
        sprintf(dest + strlen(dest), "    movsd [temp_float], xmm0    ; Store result\n");
        sprintf(dest + strlen(dest), "    mov rbx, [temp_float]       ; Load result back\n");
        sprintf(dest + strlen(dest), "    push rbx                    ; Push quotient\n");
        sprintf(dest + strlen(dest), "    jmp division_end            ; Skip error handling\n");
        sprintf(dest + strlen(dest), "\ndivision_by_zero:\n");
        sprintf(dest + strlen(dest), "    mov rdi, 1                  ; Exit code 1\n");
        sprintf(dest + strlen(dest), "    call exit                   ; Exit with error\n");
        sprintf(dest + strlen(dest), "\ndivision_end:\n");
    }
}

void makeCodeMod(char *dest)
{
    sprintf(dest + strlen(dest), "    pop r8                      ; Get divisor\n");
    sprintf(dest + strlen(dest), "    pop rax                     ; Get dividend\n");
    sprintf(dest + strlen(dest), "    xor rdx, rdx                ; Clear remainder\n");
    sprintf(dest + strlen(dest), "    idiv r8                     ; rax = rax / r8\n");
    sprintf(dest + strlen(dest), "    push rdx                    ; Push remainder\n");
}

void makeCodeNeg(char *dest, Type type)
{
    if (type == INTEGER)
    {
        sprintf(dest + strlen(dest), "    ; Integer negation\n");
        sprintf(dest + strlen(dest), "    pop rbx\n");
        sprintf(dest + strlen(dest), "    neg rbx\n");
        sprintf(dest + strlen(dest), "    push rbx\n");
    }
    else if (type == REAL)
    {
        sprintf(dest + strlen(dest), "    ; Float negation\n");
        sprintf(dest + strlen(dest), "    pop rbx\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rbx       ; Store float bits\n");
        sprintf(dest + strlen(dest), "    movsd xmm0, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    xorpd xmm1, xmm1            ; Clear xmm1\n");
        sprintf(dest + strlen(dest), "    subsd xmm1, xmm0            ; Negate: xmm1 = 0 - xmm0\n");
        sprintf(dest + strlen(dest), "    movsd [temp_float], xmm1    ; Store result\n");
        sprintf(dest + strlen(dest), "    mov rbx, [temp_float]       ; Load result back\n");
        sprintf(dest + strlen(dest), "    push rbx\n");
    }
}

// Implementation of new functions for I/O
void makeCodeRead(char *dest, char *varname, Type type)
{
    // Initialize dest string
    dest[0] = '\0';

    if (type == INTEGER)
    {
        strcat(dest, "    lea rdi, [fmt_d]            ; Integer format\n");
        sprintf(dest + strlen(dest), "    lea rsi, [%s]               ; Variable address\n", varname);
        strcat(dest, "    mov rax, 0                  ; Clear rax for scanf\n");
        strcat(dest, "    call scanf                  ; Call scanf\n");
    }
    else if (type == REAL)
    {
        strcat(dest, "    lea rdi, [fmt_f]            ; Float format\n");
        sprintf(dest + strlen(dest), "    lea rsi, [%s]               ; Variable address\n", varname);
        strcat(dest, "    mov rax, 0                  ; Clear rax for scanf\n");
        strcat(dest, "    call scanf                  ; Call scanf\n");
    }
}

void makeCodeWrite(char *dest, Type type)
{
    if (type == INTEGER)
    {
        // Write operation for integer
        strcat(dest, "    ; Write operation for integer\n");
        strcat(dest, "    pop rbx                     ; Get value to write\n");
        strcat(dest, "    mov rsi, rbx                ; Move to printf argument\n");
        strcat(dest, "    lea rdi, [fmt_dln]          ; Load format string\n");
        strcat(dest, "    mov rax, 0                  ; Clear rax for printf\n");
        strcat(dest, "    call printf                 ; Call printf\n");
    }
    else if (type == REAL)
    {
        // Write operation for float
        strcat(dest, "    ; Write operation for float\n");
        strcat(dest, "    pop rbx                     ; Get value to write\n");
        strcat(dest, "    mov [temp_float], rbx       ; Store float bits\n");
        strcat(dest, "    movsd xmm0, [temp_float]    ; Load as double\n");
        strcat(dest, "    lea rdi, [fmt_fln]          ; Load float format string\n");
        strcat(dest, "    mov rax, 1                  ; One XMM register used\n");
        strcat(dest, "    call printf                 ; Call printf\n");
    }
}
void makeCodeWriteString(char *dest, char *str)
{
    dest[0] = '\0';
    // Remove quotes from string and create a label for it
    static int string_counter = 0;
    char string_label[64];
    sprintf(string_label, "str_%d", string_counter++);

    // Add string to data section (this should be done in a separate function)
    // For now, we'll use the string directly
    int len = strlen(str);
    char clean_str[len + 1];

    // Remove the quotes
    if (str[0] == '"' && str[len - 1] == '"')
    {
        strncpy(clean_str, str + 1, len - 2);
        clean_str[len - 2] = '\0';
    }
    else
    {
        strcpy(clean_str, str);
    }

    sprintf(dest + strlen(dest), "lea rdi, [fmt_sln]\n");
    sprintf(dest + strlen(dest), "mov rsi, %s\n", clean_str);
    sprintf(dest + strlen(dest), "call printf\n");
}

// Implementation of functions for control structures
void makeCodeIf(char *dest, char *condition, char *body)
{
    int label = label_counter++;
    dest[0] = '\0';

    sprintf(dest + strlen(dest), "%s", condition);
    sprintf(dest + strlen(dest), "    pop rbx\n");
    sprintf(dest + strlen(dest), "    cmp rbx, 0\n");
    sprintf(dest + strlen(dest), "    je .L%d\n", label);
    sprintf(dest + strlen(dest), "%s", body);
    sprintf(dest + strlen(dest), "\n.L%d:\n", label);
}

void makeCodeIfElse(char *dest, char *condition, char *ifBody, char *elseBody)
{
    int label1 = label_counter++;
    int label2 = label_counter++;
    dest[0] = '\0';

    sprintf(dest + strlen(dest), "%s", condition);
    sprintf(dest + strlen(dest), "    pop rbx\n");
    sprintf(dest + strlen(dest), "    cmp rbx, 0\n");
    sprintf(dest + strlen(dest), "    je .L%d\n", label1);
    sprintf(dest + strlen(dest), "%s", ifBody);
    sprintf(dest + strlen(dest), "    jmp .L%d\n", label2);
    sprintf(dest + strlen(dest), "\n.L%d:\n", label1);
    sprintf(dest + strlen(dest), "%s", elseBody);
    sprintf(dest + strlen(dest), "\n.L%d:\n", label2);
}

void makeCodeWhile(char *dest, char *condition, char *body)
{
    int label1 = label_counter++;
    int label2 = label_counter++;
    dest[0] = '\0';

    sprintf(dest + strlen(dest), "\n.L%d:\n", label1);
    sprintf(dest + strlen(dest), "%s", condition);
    sprintf(dest + strlen(dest), "    pop rbx\n");
    sprintf(dest + strlen(dest), "    cmp rbx, 0\n");
    sprintf(dest + strlen(dest), "    je .L%d\n", label2);
    sprintf(dest + strlen(dest), "%s", body);
    sprintf(dest + strlen(dest), "    jmp .L%d\n", label1);
    sprintf(dest + strlen(dest), "\n.L%d:\n", label2);
}

// Implementation of functions for comparisons
void makeCodeComparison(char *dest, char *op, Type type)
{
    if (type == INTEGER)
    {
        sprintf(dest + strlen(dest), "    ; Integer comparison operation: %s\n", op);
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    cmp rbx, rcx                ; Compare integers\n");

        if (strcmp(op, "<") == 0)
        {
            sprintf(dest + strlen(dest), "    setl al                     ; Set if less than\n");
        }
        else if (strcmp(op, ">") == 0)
        {
            sprintf(dest + strlen(dest), "    setg al                     ; Set if greater than\n");
        }
        else if (strcmp(op, "<=") == 0)
        {
            sprintf(dest + strlen(dest), "    setle al                    ; Set if less or equal\n");
        }
        else if (strcmp(op, ">=") == 0)
        {
            sprintf(dest + strlen(dest), "    setge al                    ; Set if greater or equal\n");
        }
        else if (strcmp(op, "==") == 0)
        {
            sprintf(dest + strlen(dest), "    sete al                     ; Set if equal\n");
        }
        else if (strcmp(op, "!=") == 0)
        {
            sprintf(dest + strlen(dest), "    setne al                    ; Set if not equal\n");
        }
    }
    else if (type == REAL)
    {
        sprintf(dest + strlen(dest), "    ; Float comparison operation: %s\n", op);
        sprintf(dest + strlen(dest), "    pop rcx                     ; Get second operand\n");
        sprintf(dest + strlen(dest), "    pop rbx                     ; Get first operand\n");
        sprintf(dest + strlen(dest), "    ; Convert to float for comparison\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rbx       ; Store first operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm0, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    mov [temp_float], rcx       ; Store second operand\n");
        sprintf(dest + strlen(dest), "    movsd xmm1, [temp_float]    ; Load as double\n");
        sprintf(dest + strlen(dest), "    comisd xmm0, xmm1           ; Compare floats\n");

        if (strcmp(op, "<") == 0)
        {
            sprintf(dest + strlen(dest), "    setb al                     ; Set if less than\n");
        }
        else if (strcmp(op, ">") == 0)
        {
            sprintf(dest + strlen(dest), "    seta al                     ; Set if greater than\n");
        }
        else if (strcmp(op, "<=") == 0)
        {
            sprintf(dest + strlen(dest), "    setbe al                    ; Set if less or equal\n");
        }
        else if (strcmp(op, ">=") == 0)
        {
            sprintf(dest + strlen(dest), "    setae al                    ; Set if greater or equal\n");
        }
        else if (strcmp(op, "==") == 0)
        {
            sprintf(dest + strlen(dest), "    sete al                     ; Set if equal\n");
        }
        else if (strcmp(op, "!=") == 0)
        {
            sprintf(dest + strlen(dest), "    setne al                    ; Set if not equal\n");
        }
    }

    sprintf(dest + strlen(dest), "    movzx rbx, al               ; Zero-extend result\n");
    sprintf(dest + strlen(dest), "    push rbx                    ; Push result\n");
}

void makeCodeNot(char *dest)
{
    sprintf(dest + strlen(dest), "pop rbx\n");
    sprintf(dest + strlen(dest), "cmp rbx, 0\n");
    sprintf(dest + strlen(dest), "sete al\n");
    sprintf(dest + strlen(dest), "movzx rbx, al\n");
    sprintf(dest + strlen(dest), "push rbx\n");
}
